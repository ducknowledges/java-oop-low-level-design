# Reflection BoundedStack<T>

## Эталонное решение
```java
abstract class BoundedStack<T>

    public const int POP_NIL = 0; // push() ещё не вызывалась
    public const int POP_OK = 1; // последняя pop() отработала нормально
    public const int POP_ERR = 2; // стек пуст

    public const int PEEK_NIL = 0; // push() ещё не вызывалась
    public const int PEEK_OK = 1; // последняя peek() вернула корректное значение 
    public const int PEEK_ERR = 2; // стек пуст

    public const int PUSH_OK = 1; // последняя push() отработала нормально
    public const int PUSH_ERR = 2; // в стеке нет свободного места 

    // конструктор
// постусловие: создан новый пустой стек
    public BoundedStack<T> BoundedStack(int max_size);


    // команды:
// предусловие: в стеке менее максимального кол-ва элементов
// постусловие: в стек добавлено новое значение
    public void push(T value); 

// предусловие: стек не пустой; 
// постусловие: из стека удалён верхний элемент
    public void pop(); 

// постусловие: из стека удалятся все значения
    public void clear();


    // запросы:
// предусловие: стек не пустой
    public T peek(); 

    public int size();
    public int max_size();

    // дополнительные запросы:
    public int get_pop_status(); // возвращает значение POP_*
    public int get_peek_status(); // возвращает значение PEEK_*
    public int get_push_status(); // возвращает значение PUSH_*
```

## Рефлексия:

Принципиальных расхождений в определении АТД с эталонным решением нет. Пред и пост условия совпадают.

Единственное, упустил из вида определение запроса `max_size()`, что в целом должно быть очевидно, 
поскольку это важная часть спецификации АТД, определяющая ограничение структуры данных 
и явно может и должна использоваться в реализации.

С учетом реализации выполненной на Java:
- для ясности добавил начальный статус для команды `push()`, соответственно `PUSH_NIL = 0`.
Что бы значение статуса с типом `int` инициализировалось очевидно, значением `0`, а не по умолчанию;
- используется два конструктора, с аналогичными постусловиями. Первый для инициализации стэка 
с количеством элементов по умолчанию на 32 элемента и с заданным параметром количества элементов.

Постфактум такой подход для меня выглядит логичным, правильным и естественным, так как позволяет 
четко разделить абстрактное определение(проектирование) от непосредственной реализации. 
Помогает не смешивать эти процессы, которые чреваты ошибками и упущениями. 
Пример с `max_size` лишнее тому подтверждение.

Очень напоминает подход с использованием псевдокода при решении алгоритмической задачи, 
в которой можно сначала абстрактно рассуждать о логике работы алгоритма, разбивая проблему 
на управляемые части. А далее уже спускаться на уровень ниже, концентрируясь на тех частях, 
которые нужно и можно реализовать независимо. Это явно помогает не держать в голове большое 
количество деталей, снижая когнитивную нагрузку и лучше прорабатывать каждую часть структуры данных, 
обеспечивая корректность реализации АТД.