# Reflection LinkedList<T>

## Эталонное решение

2.2. Операция tail не должна быть сводима к другим операциям, потому что правильная 
реализация связанного списка подразумевает хранение как условного внутреннего 
элемента head_pointer (указатель на голову списка), так и условного элемента 
tail_pointer (указатель на хвост списка). В противном случае операция tail, 
выраженная через head, right и is_tail, потребовала бы O(N) ресурсов.

Это пример того, что **при проектировании АТД надо обязательно учитывать и эффективность его реализации!**

2.3. Операция поиска всех узлов с заданным значением больше не нужна, 
потому что вместо неё введена логика последовательного перемещения курсора 
к следующему искомому элементу с нужным значением.

2.1. АТД LinkedList
```java
abstract class LinkedList<T>

  // конструктор
  // постусловие: создан новый пустой список
  public LinkedList<T> LinkedList();

  // команды
  // предусловие: список не пуст; 
  // постусловие: курсор установлен на первый узел в списке
  public void head(); 

  // предусловие: список не пуст; 
  // постусловие: курсор установлен на последний узел в списке
  public void tail(); 

  // предусловие: правее курсора есть элемент; 
  // постусловие: курсор сдвинут на один узел вправо
  public void right(); 

  // предусловие: список не пуст; 
  // постусловие: следом за текущим узлом добавлен 
  // новый узел с заданным значением
  public void put_right(T value); 

  // предусловие: список не пуст; 
  // постусловие: перед текущим узлом добавлен 
  // новый узел с заданным значением
  public void put_left(T value); 

  // предусловие: список не пуст; 
  // постусловие: текущий узел удалён, 
  // курсор смещён к правому соседу, если он есть, 
  // в противном случае курсор смещён к левому соседу,
  // если он есть
  public void remove();

  // постусловие: список очищен от всех элементов
  public void clear(); 

  // постусловие: новый узел добавлен в хвост списка
  public void add_tail(T value); 

  // постусловие: в списке удалены все узлы с заданным значением
  public void remove_all(T value);

  // предусловие: список не пуст;
  // постусловие: значение текущего узла заменено на новое
  public void replace(T value); 

  // постусловие: курсор установлен на следующий узел 
  // с искомым значением, если такой узел найден
  public void find(T value); 

  // запросы
  public T get(); // предусловие: список не пуст
  public bool is_head();
  public bool is_tail();
  public bool is_value();
  public int size();

  // запросы статусов (возможные значения статусов)
  public int get_head_status(); // успешно; список пуст
  public int get_tail_status(); // успешно; список пуст
  public int get_right_status(); // успешно; правее нету элемента
  public int get_put_right_status(); // успешно; список пуст
  public int get_put_left_status(); // успешно; список пуст
  public int get_remove_status(); // успешно; список пуст
  public int get_replace_status(); // успешно; список пуст
  public int get_find_status(); // следующий найден; 
                       // следующий не найден; список пуст
  public int get_get_status(); // успешно; список пуст
```

## Рефлексия:

Глобальных расхождений в определении АТД с эталонным решением нет. 
За исключением некоторых нюансов: 
- кажется что в пред-условии `right()` в эталонном решении нехватает определения того,
что `список не пуст` по аналогии с head() и tail()
- в эталонном решении отсутствует `add_to_empty(T value)`, в своем решении описал.
- в своем определении `add_tail(T value)` добавил пред-условие, сейчас понимаю что избыточно
тк в целом элемент может добавляться в конец пустого списка.
- в своем определении `remove_all`, дополнительно пометил поведение текущего элемента(курсора)
- кажется что в эталонном `find(T value)` не достает пред-условия о том что список `не пуст`, 
у себя это отметил

В моем случае непосредственно в формулировках пред и пост условий, решил отказаться
от деталей в виде понятий курсора и узла, на мой взгляд такая детализация показалась избыточной. 
Решил ограничиться понятиями первое, последнее, текущее значение(элемент). 
На мой взгляд получилось лаконичнее без потери сути организации АТД.

Подход кажется интересным, но крайне непривычным из-за наличия большого количества
атомарных операций, но в комбинации с вопросами в задании такой подход подталкивает 
смотреть на работу с реализацией АТД немного под другим углом.
Немного напоминает взаимодействие с роботизированной системой с дискретным состоянием.